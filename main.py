#!/usr/bin/python3

import cv2
from utils import mask2rle

# Файлы ввода-вывода
INPUT_FILE = 'input.webm'
OUTPUT_FILE = "output.csv"

# Считать видео
cap = cv2.VideoCapture(INPUT_FILE)
frame_number = 0

if cap.isOpened() == False:
    print("Error opening video file")

# Подготовить запись файла
out = open(OUTPUT_FILE, "w")
out.write("ImageID,EncodedPixels\n")

# Основной цикл
while True:
    ret, frame = cap.read()
    frame_number += 1
    
    # Пример обработки
    if ret:
        # Код для обработки кадра и нахождения границ дорожного полотна

        # Преобразование в монохромное изображение:
        # делается для упрощения анализа изображения, т.к.в более простом пространстве оттенков серого выполнять
        # алгоритмы бинаризации становится проще и быстрее, чем в полноцветном изображении.
        frameGray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        # Применение алгоритма бинаризации для выделения границ дорожного полотна:
        # с помощью алгоритма бинаризации, отделяются границы дорожного полотна. Бинаризация изображения позволяет
        # упростить работу с ним, преобразовав изображение к виду, где пиксели могут принимать только два значения
        # (черное или белое). В данном случае используются пороги (120 и 255), которые определяют, какие пиксели
        # стануть белыми, а какие - черными. Например, это может быть полезно при определении границ дорожного покрытия
        # на основе контраста с его окружением.
        _, binary = cv2.threshold(frameGray, 120, 255, cv2.THRESH_BINARY)

        # Применение морфологических операций для удаления шумов и улучшения результатов бинаризации:
        # Эти операции обеспечивают «очистку» изображения от мелких деталей, позволяя уменьшить количество малых
        # объектов или шумов.
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
        binary = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)

        # Применение RLE-кодирования к бинарной маске
        # RLE — это простой метод сжатия данных, который пригоден для изображений с большим количеством последовательно
        # идущих пикселей одного цвета, в данном случае маски бинарного изображения.
        rle = mask2rle(binary)

        # В конце каждого цикла результаты (ID изображения и RLE кодированные пиксели) записываются в файл "output.csv".
        out.write(f"{INPUT_FILE}_{frame_number},")
        out.write(rle)
        out.write('\n')

        # Остановить программу после обработки всех переданных кадров
        if frame_number >= cap.get(cv2.CAP_PROP_FRAME_COUNT):
            break
    else:
        break

# Завершить запись и чтение с файлов
cap.release()
out.close()

